#!/usr/bin/env python
"""
File Description: Half-Life Black Mesa example - Multi-faction temporal planning.
Demonstrates different faction objectives:
  - Military: Control zones and eliminate threats
  - Aliens: Eliminate all humans
  - Scientists/Guards: Defend Black Mesa, secure corridors, evacuate scientists
"""

# ******************************************    Libraries to be imported    ****************************************** #
from examples.half_life_black_mesa.task_based.half_life_domain import actions, methods
from examples.half_life_black_mesa.task_based.half_life_problem import (
    init_state,
    task_list_military,
    task_list_alien,
    task_list_defend,
    task_list_mixed,
    task_list_simple,
    task_list_gordon_escape
)
from ipyhop import IPyHOP
from matplotlib import pyplot as plt
from networkx import draw_planar, dfs_preorder_nodes
from networkx import DiGraph
import os


# ******************************************        Helper Functions        ****************************************** #
def save_plan_diagram(graph: DiGraph, output_path: str, root_node: int = 0, figsize=(12, 8)):
    """
    Save a planning graph diagram to a file without displaying it.
    Uses hierarchical tree layout with improved text spacing to avoid label overlap.
    
    :param graph: A planning graph generated by IPyHOP
    :param output_path: Path where to save the diagram
    :param root_node: The node to use as a root node
    :param figsize: Figure size tuple (width, height)
    """
    from networkx import draw_networkx
    import textwrap
    import math
    
    node_list = list(dfs_preorder_nodes(graph, root_node))
    sub_graph = graph.subgraph(node_list)
    n_col = {}
    n_sz = {}
    n_lbls = {}
    
    # Calculate dynamic font size based on graph size
    num_nodes = len(node_list)
    if num_nodes < 10:
        font_size = 8
        base_node_size = 1200
    elif num_nodes < 20:
        font_size = 7
        base_node_size = 1000
    elif num_nodes < 30:
        font_size = 6
        base_node_size = 800
    else:
        font_size = 5
        base_node_size = 600
    
    label_stx = "<%d>: [%d]: %s"
    for i, node in enumerate(node_list):
        # Truncate long labels and add line breaks for better spacing
        label_text = label_stx % (i, node, repr(graph.nodes[node]['info']))
        # Wrap text if too long (max 40 chars per line)
        if len(label_text) > 40:
            wrapped = '\n'.join(textwrap.wrap(label_text, width=40, break_long_words=False))
            n_lbls[node] = wrapped
        else:
            n_lbls[node] = label_text

    for node in sub_graph:
        if graph.nodes[node]['type'] == 'D':
            n_col[node] = 'red'
            n_sz[node] = int(base_node_size * 1.5)
        elif graph.nodes[node]['type'] == 'T':
            n_col[node] = 'blue'
            n_sz[node] = int(base_node_size * 0.8)
        elif graph.nodes[node]['type'] == 'G':
            n_col[node] = 'orange'
            n_sz[node] = int(base_node_size * 0.8)
        elif graph.nodes[node]['type'] == 'M':
            n_col[node] = 'chocolate'
            n_sz[node] = int(base_node_size * 0.8)
        elif graph.nodes[node]['type'] == 'A':
            n_col[node] = 'green'
            n_sz[node] = int(base_node_size * 0.5)
        elif graph.nodes[node]['type'] == 'VG' or graph.nodes[node]['type'] == 'VM':
            n_col[node] = 'gray'
            n_sz[node] = int(base_node_size * 0.3)
        else:
            raise ValueError("Invalid Node Encountered.")
    
    # Create hierarchical tree layout
    def hierarchical_layout(G, root, width=3.0, vert_gap=0.5, vert_loc=0, xcenter=0.5):
        """
        Create a hierarchical tree layout for a directed graph.
        Positions nodes in levels based on their distance from root.
        """
        def _hierarchy_pos(G, root, width=1., vert_gap=0.2, vert_loc=0, xcenter=0.5, pos=None, parent=None, parsed=[]):
            if pos is None:
                pos = {root: (xcenter, vert_loc)}
            else:
                pos[root] = (xcenter, vert_loc)
            parsed.append(root)
            children = list(G.neighbors(root))
            if not isinstance(G, DiGraph):
                children = [n for n in children if parent != n]
            if len(children) != 0:
                dx = width / len(children)
                nextx = xcenter - width/2 - dx/2
                for child in children:
                    nextx += dx
                    pos = _hierarchy_pos(G, child, width=dx, vert_gap=vert_gap,
                                        vert_loc=vert_loc-vert_gap, xcenter=nextx,
                                        pos=pos, parent=root, parsed=parsed)
            return pos
        
        return _hierarchy_pos(G, root, width, vert_gap, vert_loc, xcenter)
    
    # Calculate tree depth to adjust vertical spacing
    def get_tree_depth(G, root):
        """Calculate the maximum depth of the tree."""
        def _depth(node, visited):
            if node in visited:
                return 0
            visited.add(node)
            children = list(G.neighbors(node))
            if not children:
                return 1
            return 1 + max(_depth(child, visited) for child in children)
        return _depth(root, set())
    
    tree_depth = get_tree_depth(sub_graph, root_node)
    # Adjust vertical gap based on tree depth for better spacing
    vert_gap = max(0.8, 1.5 - tree_depth * 0.05)
    # Adjust width based on number of nodes
    width = max(4.0, math.sqrt(num_nodes) * 0.8)
    
    pos = hierarchical_layout(sub_graph, root_node, width=width, vert_gap=vert_gap)
    
    # Adjust figure size based on number of nodes and tree depth for better spacing
    if num_nodes > 20:
        figsize = (max(figsize[0], 18), max(figsize[1], tree_depth * 2.5))
    elif num_nodes > 10:
        figsize = (max(figsize[0], 16), max(figsize[1], tree_depth * 2.0))
    else:
        figsize = (max(figsize[0], 14), max(figsize[1], tree_depth * 1.8))
    
    plt.figure(figsize=figsize)
    ax = plt.gca()
    
    # Draw nodes and edges with hierarchical layout
    draw_networkx(
        sub_graph,
        pos=pos,
        node_color=[n_col[node] for node in sub_graph.nodes()],
        node_size=[n_sz[node] for node in sub_graph.nodes()],
        with_labels=True,
        labels=n_lbls,
        font_size=font_size,
        font_weight='normal',
        edge_color='gray',
        width=1.5,
        alpha=0.8,
        ax=ax,
        arrows=True,
        arrowsize=15
    )
    
    # Adjust margins to prevent text clipping
    ax.margins(0.2)
    plt.axis('off')
    plt.tight_layout(pad=2.0)
    
    plt.savefig(output_path, dpi=150, bbox_inches='tight', pad_inches=0.3)
    plt.close()


# ******************************************        Main Program Start      ****************************************** #
def main():
    print("=" * 80)
    print("HALF-LIFE BLACK MESA - MULTI-FACTION TEMPORAL PLANNING")
    print("=" * 80)
    print("\nFactions:")
    print("  - Scientists: Survive and evacuate")
    print("  - Guards: Defend Black Mesa and secure corridors")
    print("  - Aliens: Eliminate all humans")
    print("  - Military: Control zones and eliminate threats")
    print()
    
    print("Initial State:")
    print(f"  Start Time: {init_state.get_current_time()}")
    print(f"  Gordon Freeman: {'gordon_freeman' in init_state.character_faction}")
    print(f"  Scientists: {[c for c, f in init_state.character_faction.items() if f == 'scientist']}")
    print(f"  Guards: {[c for c, f in init_state.character_faction.items() if f == 'guard']}")
    print(f"  Aliens: {[c for c, f in init_state.character_faction.items() if f == 'alien']}")
    print(f"  HECU Military: {[c for c, f in init_state.character_faction.items() if f == 'military']}")
    print(f"  Locations: {list(init_state.zone_accessible.keys())}")
    print()
    
    planner = IPyHOP(methods, actions, default_origin_time='2025-01-15T08:00:00Z')
    
    # Create output directory for diagrams
    output_dir = os.path.join(os.path.dirname(__file__), 'diagrams')
    os.makedirs(output_dir, exist_ok=True)
    
    # Problem 1: Simple movement and control
    print("\n" + "=" * 80)
    print("PROBLEM 1: Simple Movement and Zone Control")
    print("=" * 80)
    plan1 = planner.plan(init_state.copy(), task_list_simple, verbose=0)
    
    if plan1:
        print("\nTemporal Plan:")
        total_time = None
        for item in plan1:
            if isinstance(item, tuple) and len(item) == 2:
                action, temporal = item
                print(f"  {action}")
                print(f"    Duration: {temporal.get('duration', 'N/A')}")
                print(f"    Start: {temporal.get('start_time', 'N/A')}")
                print(f"    End: {temporal.get('end_time', 'N/A')}")
                total_time = temporal.get('end_time', total_time)
            else:
                print(f"  {item}")
        if total_time:
            print(f"\n  Total Time: {total_time}")
        
        # Save diagram
        try:
            graph1 = planner.sol_tree
            diagram_path = os.path.join(output_dir, 'problem1_simple_control.png')
            save_plan_diagram(graph1, diagram_path, root_node=0, figsize=(12, 8))
            print(f"\n  Diagram saved to: {diagram_path}")
        except Exception as e:
            print(f"\n  Note: Could not save diagram: {e}")
    else:
        print("  No plan found")
    
    # Problem 2: Mixed scenario - Guards defend while scientists evacuate
    print("\n" + "=" * 80)
    print("PROBLEM 2: Defend Black Mesa - Secure Corridors and Evacuate")
    print("=" * 80)
    plan2 = planner.plan(init_state.copy(), task_list_mixed, verbose=0)
    
    if plan2:
        print("\nTemporal Plan:")
        total_time = None
        for item in plan2:
            if isinstance(item, tuple) and len(item) == 2:
                action, temporal = item
                print(f"  {action}")
                print(f"    Duration: {temporal.get('duration', 'N/A')}")
                print(f"    Start: {temporal.get('start_time', 'N/A')}")
                print(f"    End: {temporal.get('end_time', 'N/A')}")
                total_time = temporal.get('end_time', total_time)
            else:
                print(f"  {item}")
        if total_time:
            print(f"\n  Total Time: {total_time}")
        
        # Save diagram
        try:
            graph2 = planner.sol_tree
            diagram_path = os.path.join(output_dir, 'problem2_defend_evacuate.png')
            save_plan_diagram(graph2, diagram_path, root_node=0, figsize=(14, 10))
            print(f"\n  Diagram saved to: {diagram_path}")
        except Exception as e:
            print(f"\n  Note: Could not save diagram: {e}")
    else:
        print("  No plan found")
    
    # Problem 3: Military objective - Control zones
    print("\n" + "=" * 80)
    print("PROBLEM 3: Military Objective - Control Zones")
    print("=" * 80)
    planner3 = IPyHOP(methods, actions, default_origin_time='2025-01-15T08:00:00Z')
    plan3 = planner3.plan(init_state.copy(), task_list_military, verbose=0)
    
    if plan3:
        print("\nTemporal Plan:")
        total_time = None
        for i, item in enumerate(plan3):
            if isinstance(item, tuple) and len(item) == 2:
                action, temporal = item
                print(f"  {i+1}. {action}")
                print(f"      Duration: {temporal.get('duration', 'N/A')}")
                print(f"      Start: {temporal.get('start_time', 'N/A')}")
                print(f"      End: {temporal.get('end_time', 'N/A')}")
                total_time = temporal.get('end_time', total_time)
            else:
                print(f"  {i+1}. {item}")
        if total_time:
            print(f"\n  Total Time: {total_time}")
        
        # Save diagram immediately after planning
        try:
            graph3 = planner3.sol_tree
            diagram_path = os.path.join(output_dir, 'problem3_military_objective.png')
            save_plan_diagram(graph3, diagram_path, root_node=0, figsize=(16, 12))
            print(f"\n  Diagram saved to: {diagram_path}")
        except Exception as e:
            print(f"\n  Note: Could not save diagram: {e}")
            import traceback
            traceback.print_exc()
    else:
        print("  No plan found")
    
    # Problem 4: Defend Black Mesa (full scenario)
    print("\n" + "=" * 80)
    print("PROBLEM 4: Defend Black Mesa - Full Scenario")
    print("=" * 80)
    plan4 = planner.plan(init_state.copy(), task_list_defend, verbose=0)
    
    if plan4:
        print("\nTemporal Plan:")
        total_time = None
        for i, item in enumerate(plan4):
            if isinstance(item, tuple) and len(item) == 2:
                action, temporal = item
                print(f"  {i+1}. {action}")
                print(f"      Duration: {temporal.get('duration', 'N/A')}")
                print(f"      Start: {temporal.get('start_time', 'N/A')}")
                print(f"      End: {temporal.get('end_time', 'N/A')}")
                total_time = temporal.get('end_time', total_time)
            else:
                print(f"  {i+1}. {item}")
        if total_time:
            print(f"\n  Total Time: {total_time}")
        
        # Save diagram
        try:
            graph4 = planner.sol_tree
            diagram_path = os.path.join(output_dir, 'problem4_full_scenario.png')
            save_plan_diagram(graph4, diagram_path, root_node=0, figsize=(18, 14))
            print(f"\n  Diagram saved to: {diagram_path}")
        except Exception as e:
            print(f"\n  Note: Could not save diagram: {e}")
    else:
        print("  No plan found")
    
    print("\n" + "=" * 80)
    print("PLANNING COMPLETE")
    print("=" * 80)


if __name__ == '__main__':
    main()

